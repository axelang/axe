use stdlib/string (string);
use stdlib/errors (error, panic);

/// Execute a shell command. Returns exit status.
def exec_from_string(cmd: string): i32 {
    mut val result: i32 = 0;
    raw {
        result = system(cmd.data);
    }
    return result;
}

/// Execute a shell command with raw C string.
/// Returns exit status.
def exec(cmd: char*): i32 {
    mut val result: i32 = 0;
    raw {
        result = system(cmd);
    }
    return result;
}

/// Check if a file exists.
def file_exists(path: string): bool {
    mut val out: bool = false;
    raw {
        FILE *f = fopen(path.data, "r");
        if (f != NULL) {
            fclose(f);
            out = true;
        }
    }
    return out;
}

/// Read entire file into a newly allocated string.
def read_file(path: string): string {
    mut val out: string;

    raw {
        FILE *f = fopen(path.data, "rb");
        if (!f) {
            stdlib_errors_panic(stdlib_errors_error_create("Failed to open file"));
        }

        fseek(f, 0, SEEK_END);
        long size = ftell(f);
        fseek(f, 0, SEEK_SET);

        char *buf = (char*)malloc(size + 1);
        fread(buf, 1, size, f);
        buf[size] = 0;
        fclose(f);

        out = stdlib_string_string_create(buf);
    }

    return out;
}

/// Write a string to a file, replacing its contents.
/// Returns true on success.
def write_file(path: string, contents: string): bool {
    mut val ok: bool = false;

    raw {
        FILE *f = fopen(path.data, "wb");
        if (!f) {
            return false;
        }
        fwrite(contents.data, 1, contents.len, f);
        fclose(f);
        ok = true;
    }

    return ok;
}

use external("sys/stat.h");
use external("sys/types.h");

/// Determine if a path is a directory.
def is_directory(path: string): bool {
    mut val out: bool = false;

    platform posix {
        raw {
            struct stat sb;
            if (stat(path.data, &sb) == 0) {
                out = S_ISDIR(sb.st_mode);
            }
        }
    }

    platform windows {
        raw {
            struct _stat sb;
            if (_stat(path.data, &sb) == 0) {
                out = (sb.st_mode & _S_IFDIR) != 0;
            }
        }
    }

    return out;
}

/// Determine if a path is a regular file.
def is_file(path: string): bool {
    mut val out: bool = false;

    platform posix {
        raw {
            struct stat sb;
            if (stat(path.data, &sb) == 0) {
                out = S_ISREG(sb.st_mode);
            }
        }
    }

    platform windows {
        raw {
            struct _stat sb;
            if (_stat(path.data, &sb) == 0) {
                out = (sb.st_mode & _S_IFREG) != 0;
            }
        }
    }

    return out;
}

/// Determine if a path is a symbolic link.
/// This always returns false on Windows.
def is_symbolic_link(path: string): bool {
    mut val out: bool = false;

    platform posix {
        raw {
            struct stat sb;
            if (lstat(path.data, &sb) == 0) {
                out = S_ISLNK(sb.st_mode);
            }
        }
    }

    platform windows {
        return false;
    }
    return out;
}

test {
    assert(exec("echo test") == 0, "exec should run successfully");
    assert(write_file(string.create("testfile.txt"), string.create("hello")), "write_file should succeed");
    assert(file_exists(string.create("testfile.txt")), "file should exist after writing");
    assert(is_file(string.create("testfile.txt")), "testfile.txt should be a file");
    assert(is_directory(string.create(".")), "current directory should be a directory");
    assert(!is_symbolic_link(string.create("testfile.txt")), "testfile.txt should not be a symbolic link");
}

use std.arena (
    Arena
);

use std.io (
    print_i32
);

model Node {
    value: i32;
    next: ref Node;
}

/// Allocate a new Node from the arena and initialize it
def new_node(arena: ref Arena, value: i32): ref Node {
    mut n: ref Node = Arena.alloc(arena, sizeof(Node));
    n.value = value;
    n.next = nil;
    return n;
}

/// Push a new value to the front of the list
def list_push_front(head: ref Node, arena: ref Arena, value: i32): ref Node {
    mut new_head: ref Node = new_node(arena, value);
    new_head.next = head;
    return new_head;
}

/// Push a new value to the back of the list
def list_push_back(head: ref Node, arena: ref Arena, value: i32): ref Node {
    if head == nil {
        return new_node(arena, value);
    }

    mut cur: ref Node = head;
    loop {
        if cur.next == nil {
            break;
        }
        cur = cur.next;
    }

    cur.next = new_node(arena, value);
    return head;
}

/// Print linked list values
def list_print(head: ref Node) {
    mut cur: ref Node = head;

    loop {
        if cur == nil {
            break;
        }
        print_i32(cur.value);
        print " ";
        cur = cur.next;
    }

    println "";
}

def main() {
    mut arena: Arena = Arena.create(65536);
    mut head: ref Node = nil;

    head = list_push_front(head, addr(arena), 10);
    head = list_push_front(head, addr(arena), 5);
    head = list_push_back(head, addr(arena), 20);
    head = list_push_back(head, addr(arena), 25);

    println "List contents:";
    list_print(head);

    Arena.destroy(addr(arena));
    println "Arena destroyed.";
}
